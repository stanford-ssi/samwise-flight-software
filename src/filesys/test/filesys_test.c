/**
 * @author Ayush Garg
 * @date 2026-01-15
 * @brief Unit tests for the filesystem module.
 *
 * Unit tests for the filesystem module.
 * Note most of these were generated by Claude Opus 4.5.
 */
#define LFS_YES_TRACE

#include "filesys.h"

// Helper macro for test assertions with error messages
#define TEST_ASSERT(cond, msg)                                                 \
    do                                                                         \
    {                                                                          \
        if (!(cond))                                                           \
        {                                                                      \
            LOG_ERROR("ASSERTION FAILED: %s\n", msg);                          \
            return -1;                                                         \
        }                                                                      \
    } while (0)

// Helper function to initialize a clean filesystem for testing
static int setup_clean_filesystem(slate_t *slate)
{
    lfs_ssize_t code = filesys_reformat(slate);
    if (code < 0)
    {
        LOG_ERROR("Failed to reformat filesystem for test setup: %d\n", code);
        return -1;
    }
    return 0;
}

// ============================================================================
// Test 1: Basic write and readback (original test)
// ============================================================================
int filesys_test_write_readback()
{
    LOG_DEBUG("=== Test: Write and Readback ===\n");

    slate_t test_slate;
    if (setup_clean_filesystem(&test_slate) < 0)
        return -1;

    lfs_ssize_t res;

    FILESYS_BUFFERED_FNAME_STR_T fname_str = "A3";
    FILESYS_BUFFERED_FILE_CRC_T crc =
        0x100ECE8C; // Precomputed CRC for 0x00..0x3F

    int8_t code =
        filesys_start_file_write(&test_slate, fname_str, 64, crc, &res);

    if (code < 0)
    {
        LOG_ERROR("Failed to start file write for testing: %d\n", code);
        return -1;
    }

    LOG_DEBUG("Returned code from start_file_write: %d\n", code);
    TEST_ASSERT(
        test_slate.filesys_is_writing_file,
        "filesys_is_writing_file should be true after start_file_write");

    uint8_t buffer[64];
    for (uint8_t i = 0; i < 64; i++)
        buffer[i] = i;

    code = filesys_write_data_to_buffer(&test_slate, buffer, sizeof(buffer), 0);

    if (code < 0)
    {
        LOG_ERROR("Failed to write data to buffer for testing: %d\n", code);
        return -1;
    }

    TEST_ASSERT(test_slate.filesys_buffer_is_dirty,
                "Buffer should be dirty after write_data_to_buffer");

    // lfs_ssize_t code_lfs =
    //     filesys_write_buffer_to_mram(&test_slate, sizeof(buffer));

    // if (code_lfs < 0)
    // {
    //     LOG_ERROR("Failed to write buffer to MRAM for testing: %d\n",
    //     code_lfs); return -1;
    // }

    // TEST_ASSERT(!test_slate.filesys_buffer_is_dirty,
    //             "Buffer should be clean after write_buffer_to_mram");

    // code = filesys_complete_file_write(&test_slate);
    code = filesys_cancel_file_write(&test_slate);

    // if (code < 0)
    // {
    //     LOG_ERROR("Failed to complete file write for testing: %d\n", code);
    //     return -1;
    // }

    // TEST_ASSERT(!test_slate.filesys_is_writing_file,
    //             "filesys_is_writing_file should be false after "
    //             "complete_file_write");

    // int8_t read_buffer[64];
    // lfs_file_t read_file;
    // lfs_file_opencfg(&test_slate.lfs, &read_file, fname_str, LFS_O_RDONLY,
    //                  &(struct lfs_file_config){.buffer = cache_buffer});

    // lfs_file_read(&test_slate.lfs, &read_file, read_buffer,
    //               sizeof(read_buffer));

    // lfs_file_close(&test_slate.lfs, &read_file);

    // for (size_t i = 0; i < sizeof(read_buffer); i++)
    //     if (read_buffer[i] != buffer[i])
    //     {
    //         LOG_ERROR("Data mismatch at byte %zu: expected %u, got %u\n", i,
    //                   buffer[i], read_buffer[i]);
    //         return -1;
    //     }

    // LOG_DEBUG("=== Test PASSED: Write and Readback ===\n");
    return 0;
}

// ============================================================================
// Test 2: Initialize and reformat
// ============================================================================
int filesys_test_initialize_reformat()
{
    LOG_DEBUG("=== Test: Initialize and Reformat ===\n");

    slate_t test_slate;

    // Test reformat
    lfs_ssize_t code = filesys_reformat(&test_slate);
    TEST_ASSERT(code >= 0, "filesys_reformat should succeed");
    TEST_ASSERT(!test_slate.filesys_is_writing_file,
                "filesys_is_writing_file should be false after reformat");
    TEST_ASSERT(!test_slate.filesys_buffer_is_dirty,
                "filesys_buffer_is_dirty should be false after reformat");

    // Verify filesystem is mounted by checking fs size
    lfs_ssize_t fs_size = lfs_fs_size(&test_slate.lfs);
    TEST_ASSERT(fs_size >= 0, "Filesystem should be accessible after reformat");

    LOG_DEBUG("=== Test PASSED: Initialize and Reformat ===\n");
    return 0;
}

// ============================================================================
// Test 3: Start file write - error when already writing
// ============================================================================
int filesys_test_start_file_write_already_writing()
{
    LOG_DEBUG("=== Test: Start File Write - Already Writing ===\n");

    slate_t test_slate;
    if (setup_clean_filesystem(&test_slate) < 0)
        return -1;

    lfs_ssize_t blocks_left;
    FILESYS_BUFFERED_FNAME_STR_T fname1 = "F1";
    FILESYS_BUFFERED_FNAME_STR_T fname2 = "F2";

    // Start first file write
    int8_t code = filesys_start_file_write(&test_slate, fname1, 64, 0x12345678,
                                           &blocks_left);
    TEST_ASSERT(code == 0, "First start_file_write should succeed");

    // Try to start a second file write while first is in progress
    code = filesys_start_file_write(&test_slate, fname2, 64, 0x87654321,
                                    &blocks_left);
    TEST_ASSERT(
        code == -1,
        "Second start_file_write should fail with -1 (already writing)");

    // Clean up
    code = filesys_cancel_file_write(&test_slate);
    TEST_ASSERT(code == 0, "cancel_file_write should succeed");

    LOG_DEBUG("=== Test PASSED: Start File Write - Already Writing ===\n");
    return 0;
}

// ============================================================================
// Test 4: Write data to buffer - offset and size validation
// ============================================================================
int filesys_test_write_data_to_buffer_bounds()
{
    LOG_DEBUG("=== Test: Write Data to Buffer - Bounds Checking ===\n");

    slate_t test_slate;
    if (setup_clean_filesystem(&test_slate) < 0)
        return -1;

    lfs_ssize_t blocks_left;
    FILESYS_BUFFERED_FNAME_STR_T fname = "BT";

    int8_t code =
        filesys_start_file_write(&test_slate, fname, 256, 0x0, &blocks_left);
    TEST_ASSERT(code == 0, "start_file_write should succeed");

    uint8_t small_buffer[16] = {0};

    // Test: Write at offset 0 with valid size
    code = filesys_write_data_to_buffer(&test_slate, small_buffer, 16, 0);
    TEST_ASSERT(code == 0, "Writing 16 bytes at offset 0 should succeed");

    // Test: Write exceeding buffer size should fail
    code = filesys_write_data_to_buffer(&test_slate, small_buffer, 16,
                                        FILESYS_BUFFER_SIZE - 8);
    TEST_ASSERT(code == -1, "Writing past buffer boundary should fail with -1");

    // Clean up
    code = filesys_cancel_file_write(&test_slate);
    TEST_ASSERT(code == 0, "cancel_file_write should succeed");

    LOG_DEBUG("=== Test PASSED: Write Data to Buffer - Bounds Checking ===\n");
    return 0;
}

// ============================================================================
// Test 5: Write data to buffer - no file being written
// ============================================================================
int filesys_test_write_data_to_buffer_no_file()
{
    LOG_DEBUG("=== Test: Write Data to Buffer - No File Being Written ===\n");

    slate_t test_slate;
    if (setup_clean_filesystem(&test_slate) < 0)
        return -1;

    uint8_t buffer[16] = {0};

    // Try to write to buffer without starting a file write
    int8_t code = filesys_write_data_to_buffer(&test_slate, buffer, 16, 0);
    TEST_ASSERT(code == -2,
                "Writing to buffer without file write should fail with -2");

    LOG_DEBUG(
        "=== Test PASSED: Write Data to Buffer - No File Being Written ===\n");
    return 0;
}

// ============================================================================
// Test 6: Write buffer to MRAM - no file being written
// ============================================================================
int filesys_test_write_buffer_to_mram_no_file()
{
    LOG_DEBUG("=== Test: Write Buffer to MRAM - No File Being Written ===\n");

    slate_t test_slate;
    if (setup_clean_filesystem(&test_slate) < 0)
        return -1;

    // Try to write buffer to MRAM without starting a file write
    lfs_ssize_t code = filesys_write_buffer_to_mram(&test_slate, 64);
    TEST_ASSERT(
        code == -1,
        "Writing buffer to MRAM without file write should fail with -1");

    LOG_DEBUG(
        "=== Test PASSED: Write Buffer to MRAM - No File Being Written ===\n");
    return 0;
}

// ============================================================================
// Test 7: Write buffer to MRAM - clean buffer (no-op)
// ============================================================================
int filesys_test_write_buffer_to_mram_clean_buffer()
{
    LOG_DEBUG("=== Test: Write Buffer to MRAM - Clean Buffer ===\n");

    slate_t test_slate;
    if (setup_clean_filesystem(&test_slate) < 0)
        return -1;

    lfs_ssize_t blocks_left;
    FILESYS_BUFFERED_FNAME_STR_T fname = "CB";

    int8_t code =
        filesys_start_file_write(&test_slate, fname, 64, 0x0, &blocks_left);
    TEST_ASSERT(code == 0, "start_file_write should succeed");

    // Buffer is clean (not dirty), so write_buffer_to_mram should return 0
    TEST_ASSERT(!test_slate.filesys_buffer_is_dirty,
                "Buffer should be clean after start_file_write");

    lfs_ssize_t bytes_written = filesys_write_buffer_to_mram(&test_slate, 64);
    TEST_ASSERT(bytes_written == 0,
                "Writing clean buffer should return 0 (no-op)");

    // Clean up
    code = filesys_cancel_file_write(&test_slate);
    TEST_ASSERT(code == 0, "cancel_file_write should succeed");

    LOG_DEBUG("=== Test PASSED: Write Buffer to MRAM - Clean Buffer ===\n");
    return 0;
}

// ============================================================================
// Test 8: Complete file write - buffer is dirty
// ============================================================================
int filesys_test_complete_file_write_dirty_buffer()
{
    LOG_DEBUG("=== Test: Complete File Write - Dirty Buffer ===\n");

    slate_t test_slate;
    if (setup_clean_filesystem(&test_slate) < 0)
        return -1;

    lfs_ssize_t blocks_left;
    FILESYS_BUFFERED_FNAME_STR_T fname = "DB";

    int8_t code =
        filesys_start_file_write(&test_slate, fname, 64, 0x0, &blocks_left);
    TEST_ASSERT(code == 0, "start_file_write should succeed");

    // Write data to buffer (makes it dirty)
    uint8_t buffer[16] = {1, 2, 3, 4};
    code = filesys_write_data_to_buffer(&test_slate, buffer, 16, 0);
    TEST_ASSERT(code == 0, "write_data_to_buffer should succeed");
    TEST_ASSERT(test_slate.filesys_buffer_is_dirty, "Buffer should be dirty");

    // Try to complete file write with dirty buffer
    FILESYS_BUFFERED_FILE_CRC_T crc;
    code = filesys_complete_file_write(&test_slate, &crc);
    TEST_ASSERT(code == -1,
                "complete_file_write with dirty buffer should fail with -1");

    // Clean up
    code = filesys_cancel_file_write(&test_slate);
    TEST_ASSERT(code == 0, "cancel_file_write should succeed");

    LOG_DEBUG("=== Test PASSED: Complete File Write - Dirty Buffer ===\n");
    return 0;
}

// ============================================================================
// Test 9: Cancel file write
// ============================================================================
int filesys_test_cancel_file_write()
{
    LOG_DEBUG("=== Test: Cancel File Write ===\n");

    slate_t test_slate;
    if (setup_clean_filesystem(&test_slate) < 0)
        return -1;

    lfs_ssize_t blocks_left;
    FILESYS_BUFFERED_FNAME_STR_T fname = "CA";

    int8_t code =
        filesys_start_file_write(&test_slate, fname, 64, 0x0, &blocks_left);
    TEST_ASSERT(code == 0, "start_file_write should succeed");

    // Write some data
    uint8_t buffer[32];
    for (int i = 0; i < 32; i++)
        buffer[i] = i;
    code = filesys_write_data_to_buffer(&test_slate, buffer, 32, 0);
    TEST_ASSERT(code == 0, "write_data_to_buffer should succeed");

    // Write buffer to MRAM
    filesys_write_buffer_to_mram(&test_slate, 32);

    // Cancel the file write
    code = filesys_cancel_file_write(&test_slate);
    TEST_ASSERT(code == 0, "cancel_file_write should succeed");
    TEST_ASSERT(!test_slate.filesys_is_writing_file,
                "filesys_is_writing_file should be false after cancel");
    TEST_ASSERT(!test_slate.filesys_buffer_is_dirty,
                "Buffer should be clean after cancel");

    // Verify file was deleted (try to open it)
    lfs_file_t file;
    int err =
        lfs_file_opencfg(&test_slate.lfs, &file, fname, LFS_O_RDONLY,
                         &(struct lfs_file_config){.buffer = cache_buffer});
    TEST_ASSERT(err < 0, "File should not exist after cancel_file_write");

    LOG_DEBUG("=== Test PASSED: Cancel File Write ===\n");
    return 0;
}

// ============================================================================
// Test 10: Cancel file write - no file being written
// ============================================================================
int filesys_test_cancel_file_write_no_file()
{
    LOG_DEBUG("=== Test: Cancel File Write - No File Being Written ===\n");

    slate_t test_slate;
    if (setup_clean_filesystem(&test_slate) < 0)
        return -1;

    // Try to cancel without starting a file write
    int8_t code = filesys_cancel_file_write(&test_slate);
    TEST_ASSERT(code == -1,
                "cancel_file_write without file should fail with -1");

    LOG_DEBUG(
        "=== Test PASSED: Cancel File Write - No File Being Written ===\n");
    return 0;
}

// ============================================================================
// Test 11: Clear buffer
// ============================================================================
int filesys_test_clear_buffer()
{
    LOG_DEBUG("=== Test: Clear Buffer ===\n");

    slate_t test_slate;
    if (setup_clean_filesystem(&test_slate) < 0)
        return -1;

    lfs_ssize_t blocks_left;
    FILESYS_BUFFERED_FNAME_STR_T fname = "CL";

    int8_t code =
        filesys_start_file_write(&test_slate, fname, 64, 0x0, &blocks_left);
    TEST_ASSERT(code == 0, "start_file_write should succeed");

    // Write data to make buffer dirty
    uint8_t buffer[16] = {0};
    code = filesys_write_data_to_buffer(&test_slate, buffer, 16, 0);
    TEST_ASSERT(code == 0, "write_data_to_buffer should succeed");
    TEST_ASSERT(test_slate.filesys_buffer_is_dirty, "Buffer should be dirty");

    // Clear the buffer
    filesys_clear_buffer(&test_slate);
    TEST_ASSERT(!test_slate.filesys_buffer_is_dirty,
                "Buffer should be clean after clear_buffer");

    // Clean up
    code = filesys_cancel_file_write(&test_slate);
    TEST_ASSERT(code == 0, "cancel_file_write should succeed");

    LOG_DEBUG("=== Test PASSED: Clear Buffer ===\n");
    return 0;
}

// ============================================================================
// Test 12: CRC verification - correct CRC
// ============================================================================
int filesys_test_crc_correct()
{
    LOG_DEBUG("=== Test: CRC Verification - Correct CRC ===\n");

    slate_t test_slate;
    if (setup_clean_filesystem(&test_slate) < 0)
        return -1;

    lfs_ssize_t blocks_left;
    FILESYS_BUFFERED_FNAME_STR_T fname = "CR";
    // CRC32 for bytes 0x00..0x3F (64 bytes)
    FILESYS_BUFFERED_FILE_CRC_T correct_crc = 0x100ECE8C;

    int8_t code = filesys_start_file_write(&test_slate, fname, 64, correct_crc,
                                           &blocks_left);
    TEST_ASSERT(code == 0, "start_file_write should succeed");

    uint8_t buffer[64];
    for (uint8_t i = 0; i < 64; i++)
        buffer[i] = i;

    code = filesys_write_data_to_buffer(&test_slate, buffer, 64, 0);
    TEST_ASSERT(code == 0, "write_data_to_buffer should succeed");

    lfs_ssize_t bytes = filesys_write_buffer_to_mram(&test_slate, 64);
    TEST_ASSERT(bytes == 64, "write_buffer_to_mram should write 64 bytes");

    // Check CRC
    FILESYS_BUFFERED_FILE_CRC_T crc;
    int8_t crc_result = filesys_is_crc_correct(&test_slate, &crc);
    TEST_ASSERT(crc_result == 0, "CRC should be correct (return 0)");

    // Complete file write (should succeed with correct CRC)
    code = filesys_complete_file_write(&test_slate, &crc);
    TEST_ASSERT(code == 0,
                "complete_file_write should succeed with correct CRC");

    LOG_DEBUG("=== Test PASSED: CRC Verification - Correct CRC ===\n");
    return 0;
}

// ============================================================================
// Test 13: CRC verification - incorrect CRC
// ============================================================================
int filesys_test_crc_incorrect()
{
    LOG_DEBUG("=== Test: CRC Verification - Incorrect CRC ===\n");

    slate_t test_slate;
    if (setup_clean_filesystem(&test_slate) < 0)
        return -1;

    lfs_ssize_t blocks_left;
    FILESYS_BUFFERED_FNAME_STR_T fname = "IC";
    // Intentionally wrong CRC
    FILESYS_BUFFERED_FILE_CRC_T wrong_crc = 0xDEADBEEF;

    int8_t code = filesys_start_file_write(&test_slate, fname, 64, wrong_crc,
                                           &blocks_left);
    TEST_ASSERT(code == 0, "start_file_write should succeed");

    uint8_t buffer[64];
    for (uint8_t i = 0; i < 64; i++)
        buffer[i] = i;

    code = filesys_write_data_to_buffer(&test_slate, buffer, 64, 0);
    TEST_ASSERT(code == 0, "write_data_to_buffer should succeed");

    lfs_ssize_t bytes = filesys_write_buffer_to_mram(&test_slate, 64);
    TEST_ASSERT(bytes == 64, "write_buffer_to_mram should write 64 bytes");

    // Check CRC - should fail
    FILESYS_BUFFERED_FILE_CRC_T crc;
    int8_t crc_result = filesys_is_crc_correct(&test_slate, &crc);
    TEST_ASSERT(crc_result == -1, "CRC should be incorrect (return -1)");

    // Complete file write should fail due to CRC mismatch
    code = filesys_complete_file_write(&test_slate, &crc);
    TEST_ASSERT(code == -4,
                "complete_file_write should fail with -4 (CRC mismatch)");

    // Clean up - need to manually close and cleanup since complete failed
    code = filesys_cancel_file_write(&test_slate);
    TEST_ASSERT(code == 0, "cancel_file_write should succeed");

    LOG_DEBUG("=== Test PASSED: CRC Verification - Incorrect CRC ===\n");
    return 0;
}

// ============================================================================
// Test 14: CRC check - no file being written
// ============================================================================
int filesys_test_crc_no_file()
{
    LOG_DEBUG("=== Test: CRC Check - No File Being Written ===\n");

    slate_t test_slate;
    if (setup_clean_filesystem(&test_slate) < 0)
        return -1;

    // Try to check CRC without starting a file write
    FILESYS_BUFFERED_FILE_CRC_T crc;
    int8_t crc_result = filesys_is_crc_correct(&test_slate, &crc);
    TEST_ASSERT(crc_result == -2, "CRC check without file should fail with -2");

    LOG_DEBUG("=== Test PASSED: CRC Check - No File Being Written ===\n");
    return 0;
}

// ============================================================================
// Test 15: Multiple file writes in sequence
// ============================================================================
int filesys_test_multiple_files()
{
    LOG_DEBUG("=== Test: Multiple File Writes in Sequence ===\n");

    slate_t test_slate;
    if (setup_clean_filesystem(&test_slate) < 0)
        return -1;

    // Write first file
    lfs_ssize_t blocks_left;
    FILESYS_BUFFERED_FNAME_STR_T fname1 = "M1";
    uint8_t buffer1[32];
    for (int i = 0; i < 32; i++)
        buffer1[i] = i;

    // Use a simple CRC (we'll compute it properly for this test data)
    int8_t code =
        filesys_start_file_write(&test_slate, fname1, 32, 0x0, &blocks_left);
    TEST_ASSERT(code == 0, "First file start should succeed");

    code = filesys_write_data_to_buffer(&test_slate, buffer1, 32, 0);
    TEST_ASSERT(code == 0, "First file buffer write should succeed");

    filesys_write_buffer_to_mram(&test_slate, 32);

    // Cancel this file (we don't have the correct CRC)
    code = filesys_cancel_file_write(&test_slate);
    TEST_ASSERT(code == 0, "First file cancel should succeed");

    // Write second file
    FILESYS_BUFFERED_FNAME_STR_T fname2 = "M2";
    uint8_t buffer2[16];
    for (int i = 0; i < 16; i++)
        buffer2[i] = 0xFF - i;

    code = filesys_start_file_write(&test_slate, fname2, 16, 0x0, &blocks_left);
    TEST_ASSERT(code == 0, "Second file start should succeed");

    code = filesys_write_data_to_buffer(&test_slate, buffer2, 16, 0);
    TEST_ASSERT(code == 0, "Second file buffer write should succeed");

    filesys_write_buffer_to_mram(&test_slate, 16);

    // Cancel second file
    code = filesys_cancel_file_write(&test_slate);
    TEST_ASSERT(code == 0, "Second file cancel should succeed");

    LOG_DEBUG("=== Test PASSED: Multiple File Writes in Sequence ===\n");
    return 0;
}

// ============================================================================
// Test 16: Blocks left calculation
// ============================================================================
int filesys_test_blocks_left_calculation()
{
    LOG_DEBUG("=== Test: Blocks Left Calculation ===\n");

    slate_t test_slate;
    if (setup_clean_filesystem(&test_slate) < 0)
        return -1;

    lfs_ssize_t blocks_left_1, blocks_left_2;
    FILESYS_BUFFERED_FNAME_STR_T fname = "BL";

    // Get initial filesystem size
    lfs_ssize_t initial_fs_size = lfs_fs_size(&test_slate.lfs);
    TEST_ASSERT(initial_fs_size >= 0, "Should get valid fs size");

    // Start a file write and check blocks left
    int8_t code =
        filesys_start_file_write(&test_slate, fname, 1024, 0x0, &blocks_left_1);
    TEST_ASSERT(code == 0, "start_file_write should succeed");

    // Blocks left should be: block_count - current_fs_size -
    // blocks_needed_for_file For a 1024 byte file with 1024 byte blocks, we
    // need 1 block
    lfs_ssize_t expected_blocks_left =
        FILESYS_BLOCK_COUNT - initial_fs_size - 1;
    TEST_ASSERT(blocks_left_1 == expected_blocks_left,
                "Blocks left calculation should be correct");

    // Clean up
    code = filesys_cancel_file_write(&test_slate);
    TEST_ASSERT(code == 0, "cancel_file_write should succeed");

    LOG_DEBUG("=== Test PASSED: Blocks Left Calculation ===\n");
    return 0;
}

// ============================================================================
// Test 17: Multi-chunk write
// ============================================================================
int filesys_test_multi_chunk_write()
{
    LOG_DEBUG("=== Test: Multi-Chunk Write ===\n");

    slate_t test_slate;
    if (setup_clean_filesystem(&test_slate) < 0)
        return -1;

    lfs_ssize_t blocks_left;
    FILESYS_BUFFERED_FNAME_STR_T fname = "MC";

    // Start file write for a larger file (will need multiple buffer writes)
    int8_t code =
        filesys_start_file_write(&test_slate, fname, 128, 0x0, &blocks_left);
    TEST_ASSERT(code == 0, "start_file_write should succeed");

    // First chunk: write 64 bytes
    uint8_t chunk1[64];
    for (int i = 0; i < 64; i++)
        chunk1[i] = i;

    code = filesys_write_data_to_buffer(&test_slate, chunk1, 64, 0);
    TEST_ASSERT(code == 0, "First chunk write should succeed");

    lfs_ssize_t bytes = filesys_write_buffer_to_mram(&test_slate, 64);
    TEST_ASSERT(bytes == 64, "First chunk MRAM write should succeed");

    // Second chunk: write another 64 bytes
    uint8_t chunk2[64];
    for (int i = 0; i < 64; i++)
        chunk2[i] = 64 + i;

    code = filesys_write_data_to_buffer(&test_slate, chunk2, 64, 0);
    TEST_ASSERT(code == 0, "Second chunk write should succeed");

    bytes = filesys_write_buffer_to_mram(&test_slate, 64);
    TEST_ASSERT(bytes == 64, "Second chunk MRAM write should succeed");

    // Cancel since we don't have the correct CRC
    code = filesys_cancel_file_write(&test_slate);
    TEST_ASSERT(code == 0, "cancel_file_write should succeed");

    LOG_DEBUG("=== Test PASSED: Multi-Chunk Write ===\n");
    return 0;
}

// ============================================================================
// Test 18: Write at offset
// ============================================================================
int filesys_test_write_at_offset()
{
    LOG_DEBUG("=== Test: Write at Offset ===\n");

    slate_t test_slate;
    if (setup_clean_filesystem(&test_slate) < 0)
        return -1;

    lfs_ssize_t blocks_left;
    FILESYS_BUFFERED_FNAME_STR_T fname = "OF";

    int8_t code =
        filesys_start_file_write(&test_slate, fname, 64, 0x0, &blocks_left);
    TEST_ASSERT(code == 0, "start_file_write should succeed");

    // Write at different offsets
    uint8_t data1[16] = {0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
                         0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA};
    uint8_t data2[16] = {0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB,
                         0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB};

    // Write first 16 bytes at offset 0
    code = filesys_write_data_to_buffer(&test_slate, data1, 16, 0);
    TEST_ASSERT(code == 0, "Write at offset 0 should succeed");

    // Write next 16 bytes at offset 32 (leaving a gap)
    code = filesys_write_data_to_buffer(&test_slate, data2, 16, 32);
    TEST_ASSERT(code == 0, "Write at offset 32 should succeed");

    // Verify data is in the buffer at the correct positions
    for (int i = 0; i < 16; i++)
    {
        TEST_ASSERT(test_slate.filesys_buffer[i] == 0xAA,
                    "Data at offset 0 should be 0xAA");
        TEST_ASSERT(test_slate.filesys_buffer[32 + i] == 0xBB,
                    "Data at offset 32 should be 0xBB");
    }

    // Clean up
    code = filesys_cancel_file_write(&test_slate);
    TEST_ASSERT(code == 0, "cancel_file_write should succeed");

    LOG_DEBUG("=== Test PASSED: Write at Offset ===\n");
    return 0;
}

#include "lfs.h"
#include "mram.h"

lfs_t lfs;
lfs_file_t file;

// ============================================================================
// Main test runner
// ============================================================================
int main()
{
    // FOR DEBUG ONLY - TO REMOVE ONCE VALGRIND STOPS COMPLAINING
    // // mount the filesystem
    // mram_write_enable();

    // lfs_format(&lfs, &cfg);
    // lfs_mount(&lfs, &cfg);

    // // read current count
    // lfs_file_opencfg(&lfs, &file, "bc", LFS_O_RDWR | LFS_O_CREAT |
    // LFS_O_APPEND,
    //                  &(struct lfs_file_config){.buffer = cache_buffer});

    // FILESYS_BUFFERED_FILE_CRC_T file_crc = 0;

    // lfs_setattr(&lfs, "bc", 0, &file_crc, sizeof(file_crc));

    // // remember the storage is not updated until the file is closed
    // successfully lfs_file_close(&lfs, &file);

    // return 0;

    LOG_DEBUG("========================================\n");
    LOG_DEBUG("Starting Filesys Test Suite\n");
    LOG_DEBUG("========================================\n");

    int result;
    int tests_passed = 0;
    int tests_failed = 0;

    // Define test functions
    struct
    {
        int (*test_func)(void);
        const char *name;
    } tests[] = {
        {filesys_test_write_readback, "Write and Readback"},
        // {filesys_test_initialize_reformat, "Initialize and Reformat"},
        // {filesys_test_start_file_write_already_writing,
        //  "Start File Write - Already Writing"},
        // {filesys_test_write_data_to_buffer_bounds,
        //  "Write Data to Buffer - Bounds Checking"},
        // {filesys_test_write_data_to_buffer_no_file,
        //  "Write Data to Buffer - No File"},
        // {filesys_test_write_buffer_to_mram_no_file,
        //  "Write Buffer to MRAM - No File"},
        // {filesys_test_write_buffer_to_mram_clean_buffer,
        //  "Write Buffer to MRAM - Clean Buffer"},
        // {filesys_test_complete_file_write_dirty_buffer,
        //  "Complete File Write - Dirty Buffer"},
        // {filesys_test_cancel_file_write, "Cancel File Write"},
        // {filesys_test_cancel_file_write_no_file, "Cancel File Write - No
        // File"}, {filesys_test_clear_buffer, "Clear Buffer"},
        // {filesys_test_crc_correct, "CRC Verification - Correct"},
        // {filesys_test_crc_incorrect, "CRC Verification - Incorrect"},
        // {filesys_test_crc_no_file, "CRC Check - No File"},
        // {filesys_test_multiple_files, "Multiple File Writes"},
        // {filesys_test_blocks_left_calculation, "Blocks Left Calculation"},
        // {filesys_test_multi_chunk_write, "Multi-Chunk Write"},
        // {filesys_test_write_at_offset, "Write at Offset"},
    };

    int num_tests = sizeof(tests) / sizeof(tests[0]);

    for (int i = 0; i < num_tests; i++)
    {
        LOG_DEBUG("\n--- Running Test %d/%d: %s ---\n", i + 1, num_tests,
                  tests[i].name);
        result = tests[i].test_func();
        if (result == 0)
        {
            tests_passed++;
            LOG_DEBUG("--- Test %d PASSED ---\n", i + 1);
        }
        else
        {
            tests_failed++;
            LOG_ERROR("--- Test %d FAILED ---\n", i + 1);
        }
    }

    LOG_DEBUG("\n========================================\n");
    LOG_DEBUG("Test Suite Complete\n");
    LOG_DEBUG("Passed: %d / %d\n", tests_passed, num_tests);
    LOG_DEBUG("Failed: %d / %d\n", tests_failed, num_tests);
    LOG_DEBUG("========================================\n");

    if (tests_failed > 0)
    {
        LOG_ERROR("SOME TESTS FAILED!\n");
        return -1;
    }

    LOG_DEBUG("All Filesys tests passed!\n");
    return 0;
}
